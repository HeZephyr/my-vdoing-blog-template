---
title: 设计模式之代理模式详解（Java实现）
date: 2022-04-30 09:21:54
tags: 
  - 代理模式
author: 
  name: Pursuit
  link: https://github.com/unique-pure
permalink: /pages/933a7d/
categories: 
  - 开发
  - 开发框架
  - 设计模式
---
## 1 代理模式介绍

代理模式（Proxy Pattern）是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。

代理模式的变化形式非常多，常见的代理形式有远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等。

> **主要解决：** 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
>
> **何时使用：** 想在访问一个类时做一些控制。
>
> **如何解决：** 增加中间层。
>
> **关键代码：** 实现与被代理类组合。
>
> **应用实例：** 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。
>
> **优点：** 1、职责清晰。 2、高扩展性。 3、智能化。
>
> **缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
>
> **使用场景：** 按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。
>
> **注意事项：** 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

## 2 代理模式详解

### 2.1 代理模式结构

代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致地对待真实对象和代理对象，在代理模式中引入了抽象层，其结构图如下：

![在这里插入图片描述](https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cb2b5074dd504542a344522df7adba59.png)


由图可知，代理模式包含以下3个角色。

1. Subject（抽象主题角色）：<font color="red">它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</font>

2. Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便任何时候都可以代替真实主题；代理主题角色还可以控制真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。

	<font color="red">通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅单纯调用真实主题对象中的操作。</font>

3. RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接使用真实主题角色中定义的操作。

### 2.2 代理模式实现

典型的抽象主题类代码如下：

```java
public abstract class Subject {
    public abstract void request();
}
```

真实主题类继承了抽象主题类，提供了业务方法的具体实现，其典型代码如下：

```java
public class RealSubject extends Subject {
    public void request() {
        // 业务方法的具体实现代码
    }
}
```

代理类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法对功能进行扩充或约束。最简单的代理类实现代码如下：

```java
public class Proxy extends Subject {
    // 维持一个对真实主题对象的引用
    private RealSubject realSubject = new RealSubject();
    
    public void preRequest() {
        ...
    }
    public void request() {
        preRequest();
        // 调用真实主题对象的方法
        realSubject.request();
        postRequest();
    }
    public void postRequest() {
        ...
    }
}
```

### 2.3 代理模式应用举例

* **题目描述**

	> 在一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖、修改自己的注册信息、修改自己的帖子等功能；而游客只能看到别人发的帖子，没有其他权限。使用保护代理来设计该权限管理模块。

* **UML类图**

	![在这里插入图片描述](https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/4530bb5e6e1a4d3790919778469cc93e.png)


  其中，AbstractPermission 为抽象主题角色，PermissionProxy 为代理主题角色，
  RealPermission 为真实主题角色。  

* **代码**

	[代码地址](https://github.com/unique-pure/designpattern_code/tree/main/src/proxy_pattern)